//2024-05-13
1，写了完整项目的伪代码

//2024-05-14
1，使用调试的方法看代码的运行，比print出来有更好的效果
2，学习C语言中定义.h文件的方法，将全局变量放在一个全新的文件中；
   python作为解释性语言并不能像C那样在一个文件中声明函数，在另一个文件实现函数
   只能通过import的方式调用函数的方式来使用函数
3，检查代码中以前缺少的部分，并将其补上
4，目前已经修复完毕read_map(),rescale_map(),interior()

//2024-05-15
1，以前存在傅里叶转换函数与C程序不同的问题，找到一个库:pyFFTW，对标C语言的FFTW库
2，进行debug，发现一些错误并进行修改

//2024-05-27
完成fill_with_density1()函数,max_area_err()函数
完成ffb_integrate.py文件,fill_with_density.py文件    发现一个问题：在ffb_integrate运算中，容易出现除以0的情况，目前的解决策略就是缩小跳出循环的值

//2024-05-28
跑了14小时，最终在0.44左右，始终无法收敛到0.01
目前采取的办法是修改mae跳出条件的值，从41.9要降到0.01，设置了20,10,1。0.1的组
新增加了一个excel表格，用于记录mae变化的情况

//2024-05-30
1，并不是先去debug，而是先了解每一个函数，每一个变量的作用，然后从原理上去分析可能存在的问题点，再到可能的部分去debug
2，下周任务：弄清楚每个变量，函数的功能；搞懂傅里叶的作用；debug代码

//2024-06-03/04
1，熟悉各个变量，函数的含义
2，break的作用是跳出循环，但是C语言写一个循环，而我写了两个循环
首先对输入的密度函数(rho_init)进行傅里叶变换，得到傅里叶系数(rho_ft)。
使用这些傅里叶系数计算每个点的速度分量(grid_flux_init,grid_fluxy_init)。
在计算过程中，傅里叶变换只需在开始时计算一次，然后在每一步计算中使用这些结果，这显著提高了计算效率。

//2024-06-05
步进 (Step Over)：F8
步入 (Step Into)：F7
步出 (Step Out)：Shift + F8
设置断点后继续执行：

调试跳过for循环的办法：
在 for 循环后面的第一行代码设置一个断点。
开始调试并在 for 循环处按 F9（继续执行），程序会跳过整个 for 循环并在你设置的断点处暂停。
使用“运行到光标处”功能：

将光标放置在 for 循环之后的第一行代码。
按 Alt + F9（运行到光标处），程序会跳过整个 for 循环并在光标处暂停。

1，经过调试发现xyhalfshift2reg呈现出来的图是经过旋转的，现在把它旋转90度之后在进行变形
2，以往的数据结构使用的是列表，感觉在应对这种程度的计算时，如果将L调到512将会非常慢，所以打算改到numpy数据结构
3，如果 rho 非常接近零，可能会引发错误
4，出现delta_t先下降到比价小的值又反弹的情况

要求：加上向量箭头图，代码中还存在bug，找到并解决

//2024-06-11
1，使用cProfile对主函数性能分析，使用pstats模块查看和分析性能结果
ncalls：调用函数的次数，78/1，表示该函数被调用了78次，其中1次是递归调用。
tottime: 函数自身的总执行时间（不包括调用的子函数）
percall: tottime 除以 ncalls，即每次调用的平均执行时间
cumtime: 函数及其所有子函数的累计执行时间
percall (cumtime/ncalls): cumtime 除以 ncalls，即每次调用的平均累计执行时间。
filename(function): 文件名、行号和函数名。
2，可视化gridvx,gridvy
(1)gridvx,gridvy的值太小了，可视化的合向量看不出来，只能乘以一定的倍数才能看到
3，debug思路：黄鸭方法
4,rho_ft的值大部分在0附近

#2024-06-13
1,通过debug发现，老是会卡在(mid[i,j,0] - eul[i,j,0]) **2 + (mid[i,j,1] - eul[i,j,1]) **2这段代码出不来，觉得把ABS_TOL的值调大

讨论结果：
1，调一个好看的高斯模糊图---高斯模糊图用边界线叠加高斯模糊结果
2，根据高斯模糊得到准确的速度图

DCT（离散余弦变换）是一种用于信号处理的工具，它可以将空间域的数据转换到频域。这是因为DCT将低频分量放在左上角，高频分量放在右下角。
离散余弦变换DCT https://blog.csdn.net/qq_36002089/article/details/130854194

#2024-06-20
先全选
左移：Shitf + Tab
右移：Tab

把所有飞矩阵的数据重新定义成矩阵的格式，这样应该不存在图像颠倒的情况
1，查看scale后的地图是什么样子:目前发现，rescale的中国地图还是正常的在interior之后，图像就变换了角度    不是很清楚为什么就旋转了角度
2，画一个实际的效果图出来，存在边界的，线条时候一个好看的图再跑整个过程

组会结果：
1，记录mae下降的拐点；
2，观察当mae下降到拐点时，各个密度之间的误差会否达到一个误差以内
3，图形复色，按照4色情况对图形合理复色，两个区域之间颜色不相同
4，使用官网下载的SVG图叠加到自己的图中查看差异
5，把系统运行起来，在系统中除了可以看到最终结果，还可以查看运行结果
6，速度分析一下，看看哪里更加耗时间

//2024-06-27
优化策略：1，使用numpy;2，利用Cpython；3，使用多线程
GeoPandas是专门用于地理数据处理的Pandas扩展，可以方便地处理GeoJSON数据，并且在底层使用了高效的数值计算库。目前已经改了大部分for循环代码，提高了效率；
python受限于全局解释器锁(GIL),这意味着使用多线程对于需要频繁使用CPU的python任务作用并不明显；使用多进程会更加合适

在interior阶段太耗费时间了，应该想办法把它降下来；另外，考虑在ffb阶段使用多进程方法；

//2024-07-04
学习一下numpy和多进程编程
1，优化代码:继续调整数据结构；使用多进程的方法；因为GIL的限制导致多线程方法受限，但是多进程开辟进程开销太大了反而降低了速度
2，使用城市数据

目前在减少IO输出的情况下，4分钟能跑完；
占用内存大概500M

//2024-07-11
使用 multiprocessing 进行并行计算时，涉及大量的数据传输和进程间通信，这可能会导致性能下降，特别是当数据量很大时。
在循环中频繁创建和销毁池实例可能会在性能方面造成很大的损失。最好创建一次池，然后将其重用于多个并行任务。

重新写一个流程图

//2024-07-18
重新绘制流程图

下一步，根据目前随机值，获取城市向量
第二步，根据概念距离计算变形后城市之间的距离

//2024-07-31
目前问题卡在傅里叶变换上面，如果解决傅里叶变换类型能够准确展现，应该能不错的效果
目标，使用pytorch实现对应的傅里叶变换

学习一套系统的用于调试代码的方法，而不是靠瞎猜：5why，找bug

//2024-09-02
实现步骤：
1，初始化：输入省会之间的最终距离，输入省份人口数据
2，地图变形：使用cartogram算法根据人口数据调整省份面积
3，计算省会间的距离：使用欧几里得距离计算误差
4，优化：优化算法(梯度下降，遗传算法，模拟退火)来不断调整输入的人口数据
5，终止条件：设置阈值

问题：已经能够运行完一轮，在自动微分时出现问题并且在傅里叶变换那块效果不够好影响了最终出图

1，算法思路中得出需要再cartogram改成pytorch
2，目前已经全部改好了
3，傅里叶对比图，但是傅里叶没改好，在结果图中体现
4，另外，有的地方没有获取到梯度



2024-10-08
1，目前已经实现DCT-I和DST-I，且目前实现结果和之前版本结果相同
2，DCT-I实现的效率太低了，需要改善DCT-I的效率

2024-10-15
1，RuntimeError: element 0 of tensors does not require grad and does not have a grad_fn
错误会发生在当你试图对没有 requires_grad=True 属性的张量进行 .backward() 操作
另外一种可能：m.main() 是在 CPU 上运行，而你使用的设备是 GPU，可能会出现计算图断裂的情况。请确保所有张量在同一个设备上操作。

Gradient of population_data_tensor: None 没有梯度。

科报会：1，背景；2，研究现状：基于边界点变形；3，常用研究方法：边界点变形算法
4，cartogram算法；5，迭代学习获得更精准的城市间距离(展望)；

2024-11-05
在梯度下降中，只需要追踪你想要优化的变量的梯度。其他不需要优化的变量无需追踪梯度，因为这会增加不必要的计算和内存开销，并且无助于优化目标的收敛。

#2024-11-12
torch.autograd.grad(error, g.population_data_tensor, retain_graph=True, allow_unused=True)的返回结果显示从g.population_data_tensor到error的计算链条是完整的没有断开
把population_data_tensor微调之后误差发生较小的变化，说明population_data_tensor对于目标函数的敏感性低
提高敏感性的方法：1，增加正则化项；2，调整高斯模糊参数，减少梯度削弱；3，误差函数归一化处理
在2轮循环中fill_with_density1出错

g.population_data_tensor.grad_fn一直是none
变形图依赖于人口数据，那么在计算变形图的过程中，人口数据必须是可微的，并且参与计算。

#2025-01-02
修改girdvx，gridvy后出现问题
任务：省级变形

#2025-01-14
目前任务：验证模型是否有效
    使用省级真实人口数据，运行变形算法得到变形后省级间真实距离作为目标距离(target_distance)，在真实人口数据的基础上加上自身的一半，
例如A省份人口100，更改后A省份人口为150，最终得到机器学习输入人口数据。使用机器学习模型，基于变形算法得到的geo_distance与target_distance
做差的平方构建误差函数。
    这次验证和以前的方法有两点不同，没有对人口数据做归一化，没有对target_distance和geo_distance做归一化处理，因为归一化处理一定会出现
0，不进行归一化避免了这个情况。
    使用subprocess的方法，避免了在error_backward的时候累积的情况，程序能够在服务器上无限运行。
    目前，loss从45000降到了400

#2025-02-24
1,城市级别训练增加台湾地区
    通过爬虫已经爬取了369个城市从19年到23年的迁徙规模指数。迁徙规模指数反应各个城市的迁入和迁出规模。
    目前缺少几个城市的迁入比例数据